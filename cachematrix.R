## The following pair of functions can be used together to inverse a matrix and
## to keep this inverted matrix in the cache in order to avoid recomputing it

## The following function generates a list that is able to 
    # 1. set the matrix to-be-inverted
    # 2. return that matrix
    # 3. set the inverted matrix
    # 4. return the inverted matrix (aka create a cache!)

makeCacheMatrix <- function(x = matrix()) { # the argument here is a matrix 
    #that needs to be inverted
    inv <- NULL
    set <- function(matrA){ # set() generates a matrix based on the given matrA
        x <<- matrA   # the value x is set in the global environment
        inv <<- NULL
    }
    get <- function() x # get() returns matrA (now x) -- no arguments
    set_inv <- function(inverted) inv <<- inverted # sets the value of the inverted matrix
    get_inv <- function() inv # gets the inverted matrix
    list(set = set, get = get,
         set_inv = set_inv,
         get_inv = get_inv)

}


## This function contains the function solve() which will invert the matrix
# generated using the function makeCacheMatrix above.
# However, it will first check if an "inv" value already exists (if the matrix
# has already been created.) In this case the return() function will stop the 
# function from running further and immediately return the already cached value.

cacheSolve <- function(x, ...) { # here, the argument x is the object generated by
    # makeCacheMatrix() 
    inv <- x$get_inv() # looks for pre-existing inverted matrix in the cache
    if(!is.null(inv)){
        message("getting cached matrix")
        return(inv) # stops the function from going further. Returns cached value
    }
    M <- x$get()
    inv <- solve(M, ...) # if no inv value present, the solve() function generates it
    x$set_inv(inv)
    inv ## Return a matrix that is the inverse of 'x'
        
}
